# linux性能优化实战



## CPU

### 1. 平均负载

单位时间内，系统处于**可运行状态**和**不可中断状态**的平均进程数，也就是平均活跃进程数，它和 CPU 使用率并没有直接关系。

- 可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。
- 不可中断状态的进程，是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。不可中断状态实际上是系统对进程和硬件设备的一种保护机制。



**平均负载最理想的情况是等于 CPU 个数**

```shell
grep 'model name' /proc/cpuinfo | wc -l

lscpu | grep 'CPU(s):'
```

**当平均负载高于 CPU 数量 70% 的时候**，就应该分析排查负载高的问题了。一旦负载过高，就可能导致进程响应变慢，进而影响服务的正常功能。但 70% 这个数字并不是绝对的，最推荐的方法，还是把系统的平均负载监控起来，然后根据更多的历史数据，判断负载的变化趋势。**当发现负载有明显升高趋势时，比如说负载翻倍了，再去做分析和调查**。



#### 案例

- stress 是一个 Linux 系统压力测试工具，用作异常进程模拟平均负载升高的场景。

- mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。
- pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。



##### 场景一：CPU密集型进程

安装 stress、sysstat

```shell
apt install stress sysstat
```



stress 命令模拟一个 CPU 使用率 100% 的场景

```shell
$ stress -c 1 -t 600
```



运行 uptime 查看平均负载的变化情况

```shell
# -d 参数表示高亮显示变化的区域
$ watch -d uptime
..., load average: 1.00, 0.75, 0.39
```



mpstat 查看 CPU 使用率的变化情况

```shell
# -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据
$ mpstat -P ALL 5
Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU)
13:30:06 CPU   %usr %nice %sys %iowait %irq %soft %steal %guest %gnice  %idle
13:30:11 all  50.05  0.00 0.00    0.00 0.00  0.00   0.00   0.00   0.00  49.95
13:30:11   0   0.00  0.00 0.00    0.00 0.00  0.00   0.00   0.00   0.00 100.00
13:30:11   1 100.00  0.00 0.00    0.00 0.00  0.00   0.00   0.00   0.00   0.00
```



pid 查看消耗 CPU 的进程

```shell
# 间隔5秒后输出一组数据
$ pidstat -u 5 1
13:37:07 UID  PID   %usr %system %guest %wait   %CPU CPU Command
13:37:12   0 2962 100.00    0.00   0.00  0.00 100.00   1  stress
```

stress 进程的 CPU 使用率为 100%。



##### 场景二：IO密集型进程

stress 模拟IO压力，不停地 sync

```shell
$ stress -i 1 -t 600
```



uptime 查看平均负载的变化情况

```shell
$ watch -d uptime
..., load average: 1.06, 0.58, 0.37
```



mpstat 查看 CPU 使用率的变化情况

```shell
# 显示所有CPU的指标，并在间隔5秒输出一组数据
$ mpstat -P ALL 5 1Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU)
13:41:28 CPU %usr %nice  %sys %iowait %irq %soft %steal %guest %gnice %idle
13:41:33 all 0.21  0.00 12.07   32.67 0.00  0.21   0.00   0.00   0.00 54.84
13:41:33   0 0.43  0.00 23.87   67.53 0.00  0.43   0.00   0.00   0.00  7.74
13:41:33   1 0.00  0.00  0.81    0.20 0.00  0.00   0.00   0.00   0.00 98.99
```

1 分钟的平均负载会慢慢增加到 1.06，其中一个 CPU 的系统 CPU 使用率升高到了 23.87，而 iowait 高达 67.53%。

这说明，平均负载的升高是由于 iowait 的升高。



pidstat 查看IO消耗高的进程

```shell
# 间隔5秒后输出一组数据，-u表示CPU指标
$ pidstat -u 5 1
Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU)
13:42:08 UID  PID %usr %system %guest %wait  %CPU CPU      Command
13:42:13   0  104 0.00    3.39   0.00  0.00  3.39   1 kworker/1:1H
13:42:13   0  109 0.00    0.40   0.00  0.00  0.40   0 kworker/0:1H
13:42:13   0 2997 2.00   35.53   0.00  3.99 37.52   1       stress
13:42:13   0 3057 0.00    0.40   0.00  0.00  0.40   0      pidstat
```



##### 场景三：大量进程

stress 模拟大量进程

```shell
$ stress -c 8 -t 600
```



uptime 查看平均负载的变化情况

```shell
$ uptime
..., load average: 7.97, 5.93, 3.02
```



pid 查看进程状态

```shell
# 间隔5秒后输出一组数据
$ pidstat -u 5 1
14:23:25 UID  PID  %usr %system %guest %wait  %CPU CPU Command
14:23:30   0 3190 25.00    0.00   0.00 74.80 25.00   0  stress
14:23:30   0 3191 25.00    0.00   0.00 75.20 25.00   0  stress
14:23:30   0 3192 25.00    0.00   0.00 74.80 25.00   1  stress
14:23:30   0 3193 25.00    0.00   0.00 75.00 25.00   1  stress
14:23:30   0 3194 24.80    0.00   0.00 74.60 24.80   0  stress
14:23:30   0 3195 24.80    0.00   0.00 75.00 24.80   0  stress
14:23:30   0 3196 24.80    0.00   0.00 74.60 24.80   1  stress
14:23:30   0 3197 24.80    0.00   0.00 74.80 24.80   1  stress
14:23:30   0 3200  0.00    0.20   0.00  0.20  0.20   0  pidstat
```

8 个进程在争抢 2 个 CPU，每个进程等待 CPU 的时间（也就是代码块中的 %wait 列）高达 75%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。



#### 小结

- 平均负载高有可能是 CPU 密集型进程导致的

- 平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了

- 当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源



### 2. 上下文切换

CPU 寄存器，是 CPU 内置的容量小、速度极快的内存。程序计数器，是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，叫做 CPU 上下文。

CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

CPU 上下文切换场景分为：进程上下文切换、线程上下文切换、中断上下文切换。



如何查看系统的上下文切换情况？

1. vmstat

vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。

```shell
# 每隔5秒输出1组数据
$ vmstat 5
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- 
r   b swpd   free   buff    cache si     so bi       bo in     cs us sy id wa st 
0   0   0 7005360  91564   818900  0      0  0        0 25     33  0  0 100 0  0
```

- cs (context switch) 是每秒上下文切换的次数
- in (interruput) 是每秒中断的次数
- r (Running or Runnable) 是就绪队列的长度，也就是正在运行和等待 CPU 的进程数
- b (Blocked) 是处于中断睡眠状态的进程数



2. pidstat

vmstat 只给出了系统总体的上下文切换情况，要想查看每个进程的详细情况，就需要使用 pidstat，加上 -w 选项，就可以查看每个进程上下文切换的情况。

```shell
# 每隔5秒输出1组数据
$ pidstat -w 5
Linux 4.15.0 (ubuntu) 09/23/18 _x86_64_ (2 CPU)

08:18:26 UID PID cswch/s nvcswch/s   Command
08:18:31   0   1    0.20      0.00   systemd
08:18:31   0   8    5.40      0.00 rcu_sched
...
```

- cswch 表示每秒自愿上下文切换的次数。
  - 指进程无法获取所需资源导致的上下文切换
  - 比如 IO、内存等系统资源不足时就会发生资源上下文切换
- nvcswch 表示每秒非自愿上下文切换的次数。
  - 指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换
  - 比如大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换



#### 案例

sysbench 模拟系统多线程调度的瓶颈

```shell
# 以10个线程运行5分钟的基准测试，模拟多线程切换的问题
$ sysbench --threads=10 --max-time=300 threads run
```



接着第二个终端运行 vmstat，观察上下文切换情况

```shell
# 每隔1秒输出1组数据（需要Ctrl+C才结束）
$ vmstat 1
procs -----------memory--------- ---swap-- -----io---- ----system--- ------cpu-----
r   b swpd   free   buff   cache si     so bi       bo    in      cs us sy id wa st
6   0   0 6487428 118240 1292772  0      0  0        0  9019 1398830 16 84  0  0  0
8   0   0 6487428 118240 1292772  0      0  0        0 10191 1392312 16 84  0  0  0
```

cs 列的上下文切换次数从 35 骤然上升到 139 万，同时注意其他几个指标：

- r：就绪队列的长度已经到达 8，远超过了系统 CPU 的个数 2，肯定有大量的 CPU 竞争
- us、sy：这两列的 CPU 使用率加起来上升到 100%，其中系统 CPU 使用率，也就是 sy 高达 84%，说明 CPU 主要是被内核占用了
- in：中断次数也上升到 1万 左右，说明中断处理也是潜在问题

综合几个指标，说明，系统的就绪队列过长，也就是正在运行和等待 CPU 的进程数过多，导致了大量的上下文切换，而上下文切换又导致了系统 CPU 的占用率升高。



pidstat 分析导致问题的进程

```shell
# 每隔1秒输出1组数据（需要 Ctrl+C 才结束）
# -w参数表示输出进程切换指标，而-u参数则表示输出CPU使用指标
$ pidstat -w -u 1
08:06:33 UID   PID  %usr %system %guest %wait   %CPU CPU      Command
08:06:34   0 10488 30.00  100.00   0.00  0.00 100.00   0     sysbench
08:06:34   0 26326  0.00    1.00   0.00  0.00   1.00   0 kworker/u4:2

08:06:33  UID   PID cswch/s nvcswch/s      Command
08:06:34    0     8   11.00      0.00    rcu_sched
08:06:34    0    16    1.00      0.00  ksoftirqd/1
08:06:34    0   471    1.00      0.00   hv_balloon
08:06:34    0  1230    1.00      0.00       iscsid
08:06:34    0  4089    1.00      0.00  kworker/1:5
08:06:34    0  4333    1.00      0.00  kworker/0:3
08:06:34    0 10499    1.00    224.00      pidstat
08:06:34    0 26326  236.00      0.00 kworker/u4:2
08:06:34 1000 26784  223.00      0.00         sshd
```

pidstat 的输出可以发现，CPU 使用率的升高时 sysbench 导致的，它的 CPU 使用率已经达到了 100%。但上下文切换则是来自其他进程，包括非自愿上下文切换频率最高的 pidstat，以及自愿上下文切换频率最高的内核线程 kworker 和 sshd。



pidstat -t 查看线程指标

```shell
# 每隔1秒输出一组数据（需要 Ctrl+C 才结束）
# -wt 参数表示输出线程的上下文切换指标
$ pidstat -wt 1
08:14:05 UID  TGID   TID  cswch/s nvcswch/s     Command
...
08:14:05   0 10551     -     6.00      0.00 sysbench
08:14:05   0     - 10551     6.00      0.00 |__sysbench
08:14:05   0     - 10552 18911.00 103740.00 |__sysbench
08:14:05   0     - 10553 18915.00 100955.00 |__sysbench
08:14:05   0     - 10554 18827.00 103954.00 |__sysbench
...
```

虽然 sysbench 进程的上下文切换次数看起来并不多，但是它的子线程的上下文切换次数却很多。



如何才能知道中断发生的类型呢？

可以从 /proc/interrupts 中读取

```shell
# -d 参数表示高亮显示变化的区域
$ watch -d cat /proc/interrupts
        CPU0    CPU1
...
RES: 2450431 5279697 Rescheduling interrupts
...
```

变化速度最快的是中调度中断（RES），这个中断类型表示唤醒空闲状态的 CPU 来调度新的任务运行。这是多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为处理器间中断。



#### 小结

- 自愿上下文切换变多了，说明进程都在等待自愿，有可能发生了 IO 等其他问题
- 非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈
- 中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 来分析具体的中断类型



## Memory



## IO



## Network



## References

https://time.geekbang.org/column/intro/100020901?tab=catalog
