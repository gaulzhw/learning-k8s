# DDD

Domain Driven Design



## 领域模型

### 服务

标识的是在领域对象之外的操作与行为，接收用户的请求和执行某些操作

- 当用户在系统界面中进行操作时，会向系统发送请求
- 服务去接收用户的这些请求，然后根据需求去执行相应的方法
- 所有操作都完成后，再将实体或值对象中的数据持久化到数据库中



### 实体

通过一个唯一标识字段来区分真实世界中的每一个个体的领域对象

- 可变性是实体的特点



### 值对象

代表的是真实世界中那些一成不变的、本质性的事物

- 不变性是值对象的本质



## 贫血模型 vs 充血模型

业务领域模型转换成程序设计



充血模型的优势：

- 保持了领域模型的原貌，可以比较直接地映射成程序的变更，代码修改起来比较直接
- 保持了对象的封装性，使得领域模型在面临多态、继承等复杂结构时，易于变更



### 充血模型的架构设计图

![rich_domain_model](img/rich_domain_model.png)



### 贫血模型的架构设计图

![anaemic_domain_model](img/anaemic_domain_model.png)



### 对比

1. 充血模型需要开发人员具有更强的 OOA/D 能力、分析业务、业务建模与设计能力
2. 充血模型需要有较强的团队协作能力
3. 贫血模型所有业务处理过程都交给 Service 去完成



贫血模型，将复杂的业务处理场景，划分成多个相对独立的步骤，然后将这些独立的步骤分配给多个 Service 串联起来执行

充血模型：将需要封装的业务逻辑放到领域对象中

贫血模型：将除此之外的业务逻辑放到 Service 中



需要封装起来按照充血模型设计的业务逻辑：

- 在领域模型中出现了类似继承、多态的情况
- 在软件设计的过程中需要将一些类型或者编码进行转换
- 希望在软件设计中能更好地表现领域对象之间的关系
- 聚合，在真实世界中那些代表整体与部分的事物



## 聚合、仓库、工厂

### 聚合

表达的是真实世界中整体与部分的关系

- 当整体不存在时，部分就变得没有了意义



- 创建订单时，将订单明细创建在订单中
- 保存订单时，同时保存订单表与订单明细表，并放在同一事务中
- 查询订单时，同时查询订单表与订单明细表，并将其装配成一个订单对象



聚合的设计思路：

- 创建或更新订单时，在订单对象中填入或更新订单的明细
- 保存订单时，只需要将订单对象作为整体去保存
- 删除订单时，删除订单对象
- 查询或装载订单时，客户程序根据查询语句或 ID 查询订单对象



聚合根：外部访问的唯一入口



在一个系统中，增删改的业务可以采用领域驱动的设计

但在非增删改的分析汇总场景中，直接 SQL 查询



### 仓库

通过订单 DAO 与订单明细 DAO 去完成数据库的保存，由订单 Service 去添加事务，这样的设计没有聚合、缺乏封装性，不利于日后的维护

采用领域驱动设计，通常就会实现一个仓库（Repository）去完成对数据库的访问

- 当数据要保存到数据库中时，由 DAO 负责保存，但保存的是某个单表
- 当数据要查询时，通过 DAO 去查询，但查询的是某个单表

通过订单仓库的封装，只需要在领域对象建模的时候设定对象间的关系，即将其设定为“聚合”



装载（Load）：通过主键 ID 去查询某条记录

- 订单仓库在查询订单时，只是简单地查询订单表
- 查询到该订单后，将其封装在订单对象中，通过查询补填用户对象、订单明细对象
- 通过补填后，会得到一个用户对象、多个订单明细对象，需要将它们装配到订单对象中



### 工厂

在设计模式中，将被调方设计成一个接口下的多个实现，将这些实现放入工厂中，工厂负责通过 key 值找到对应的实现类，创建出来返回给调用方，从而降低了调用方与被调方的耦合度



DDD 中的工厂，通过装配，创建领域对象，是领域对象生命周期的起点

比如：系统要通过 ID 装载一个订单

- 订单仓库将任务交给订单工厂，订单工厂分别调用订单 DAO、订单明细 DAO 和用户 DAO 去进行查询
- 将订单明细对象与用户对象，分别 set 到订单对象的订单明细与用户属性中（装配）
- 订单工厂将装配好的订单对象返回给订单仓库



### 对数据库的访问

如果服务器是一个非常强大的服务器，系统创建的所有领域对象都放在仓库中，当需要这些对象时，通过 ID 到仓库中去获取

当客户程序通过 ID 去获取某个领域对象时，仓库会通过这个 ID 先到缓存中进行查找

- 查找到了，则直接返回，不需要查询数据库
- 没有找到，则通知工厂，工厂调用 DAO 去数据库中查询，然后装配成领域对象返回给仓库



查询订单

- 订单仓库先通过订单 DAO 去查询订单表
- 订单 DAO 查询订单表后，会进行一个分页，将某一页的数据返回给订单仓库
- 订单仓库会将查询结果交给订单工厂，去补填其对应的用户与订单明细，完成相应的装配，将装配好的订单对象集合返回给仓库



通过仓库与工厂，对原有的 DAO 进行了一层封装

在保存、装载、查询等操作中，加入聚合、装配等操作，并将这些操作封装起来，对上层的客户程序屏蔽



## 限界上下文

将整个系统划分成许多相对独立的业务场景，在一个一个的业务场景中进行领域分析与建模，这样的业务场景称之为“问题子域”，简称“子域”

领域驱动核心的设计思想：将对软件的分析与设计还原到真实世界中，真实世界的业务与问题叫“问题域”，业务规则与知识叫“业务领域知识”

- 电商领域的问题域：人们如何进行在线购物，购物的流程是怎样的
  - 用户选购、下单、支付、物流等多个子域
- 在线订餐系统的问题域：人们如何在线订餐，饭店如何在线接单，系统是如何派送骑士去配送的
  - 用户下单、饭店接单、骑士派送等子域



一个复杂系统的领域驱动设计，是以子域为中心进行领域建模，绘制出一张一张的领域模型设计，称之为“限界上下文”（Context Bounds，CB）

限界上下文之间的相互关系，称之为“上下文地图”（Context Map）

单一职责原则：每个限界上下文中实现的都是软件变化同一个原因的业务



在用户下单的过程中，用户信息的读取是否也应该在“用户下单”这个限界上下文中实现呢？

用户信息的操作交给“用户信息管理”限界上下文



限界上下文内的高内聚：每个限界上下文内实现的功能，都是软件变化的同一个原因的代码

限界上下文间的低耦合：限界上下文通过上下文地图相互调用时，通过接口进行调用



微服务设计对设计提出了更高的要求，要求做到“高内聚”

- 从 DDD 开始需求分析、领域建模，逐渐建立起多个问题子域
- 将问题子域落实到限界上下文，它们之间的关联形成上下文地图
- 各子域落实到微服务中贫血模型或充血模型的设计，从而在微服务之间依据上下文地图形成接口



## 领域驱动设计

微服务设计最核心的难题是微服务的拆分，要讲究“小而专”的设计，要“低耦合、高内聚”

解决微服务如何拆分，实现微服务的高内聚与单一职责的问题



### 案例：在线订餐系统

在线订餐系统的业务流程图：用户选餐 -> 用户下单 -> 饭店接单 -> 餐食就绪 -> 骑士派送 -> 订单送达

如何从分析理解需求开始，通过领域驱动设计落实到拆分微服务？



统一语言建模

如何了解业务：

- 从客户那里去学习，注意捕获客户在描述业务过程中的那些专用术语，努力学会用这些专用术语与客户探讨业务



事件风暴（Event Storming）

一种基于工作坊的 DDD 事件方法，可以快速发现业务领域中正在发生的事件，指导领域建模及程序开发

事件即事实（Event as Fact），即在业务领域中那些已经发生的事件就是事实

DDD 往往应用于系统增删改的业务场景中

1. 在产品经理的引导下，与业务专家开始梳理当前的业务中有哪些领域事件，在命名的时候应当采用过去时态
2. 针对每一个领域事件，项目组成员围绕它进行业务分析，增加各种命令与事件，进而思考与之相关的资源、外部系统与时间
3. 识别模型中可能涉及的聚合及其聚合根



在线订餐系统的领域事件分析图

![ordering_domain_analyse](img/ordering_domain_analyse.png)



领域建模是将一个系统划分成多个子域，每个子域都是一个独立的业务场景，每个子域的实现就是限界上下文，它们之间的关联关系是上下文地图

通过 DDD 进行业务建模，再基于领域模型进行限界上下文划分，能保证系统的设计，在限界上下文内高内聚，在限界上下文间低耦合



已下单的限界上下文分析图

![orderd_context_bound](img/orderd_context_bound.png)



通过消息队列实现领域事件在微服务间的通知



在线订餐系统的领域事件通知

![ordering_domain_event](img/ordering_domain_event.png)



## DDD 的微服务设计

1. 按照限界上下文进行微服务的拆分，按照上下文地图定义各微服务之间的接口与调用关系
2. 将领域模型划分到多个问题子域，每个子域都有一个领域模型的设计
3. 基于充血模型与贫血模型设计各个微服务的业务领域层，即各自的 Service、Entity、Value Object
4. 按照领域模型设计各个微服务的数据库

![ording_microservice_design](img/ording_microservice_design.png)

用户 APP

- 用户注册时，调用用户注册微服务
- 用户选购时，查询饭店管理微服务
- 用户下单时，调用用户下单微服务

